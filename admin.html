<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Admin</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="modal.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    <style>
        /* Fix for dual range slider */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            pointer-events: none; /* Let clicks pass through track */
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            pointer-events: auto; /* Capture clicks on thumb */
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4dabf7;
            cursor: pointer;
            margin-top: -8px;
            position: relative;
            z-index: 10;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        
        input[type=range]::-moz-range-thumb {
            pointer-events: auto;
            height: 20px;
            width: 20px;
            border: none;
            border-radius: 50%;
            background: #4dabf7;
            cursor: pointer;
            position: relative;
            z-index: 10;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        
        /* Ensure video preview is visible */
        #editor-video-preview {
            background: #000;
            z-index: 1;
        }
    </style>
</head>
<body class="admin-body">
    
    <!-- Cropper Modal -->
    <div id="cropper-modal" class="cropper-overlay">
        <div class="cropper-container-wrapper">
            <img id="cropper-image" style="max-width: 100%;">
        </div>
        <div class="cropper-controls">
            <button id="btn-crop-cancel" class="admin-btn btn-crop-cancel">Annuler</button>
            <button id="btn-crop-confirm" class="admin-btn btn-crop-confirm">Valider</button>
        </div>
    </div>

    <!-- Video Editor Modal -->
    <div id="video-editor-modal" class="cropper-overlay" style="display:none;">
        <div class="cropper-container-wrapper" style="display:flex; flex-direction:column; align-items:center; justify-content:center; padding:20px; background:#000;">
            <h3 style="color:white; margin-bottom:15px;">√âditeur Vid√©o (Max 5-10s)</h3>
            
            <div style="position:relative; width:100%; max-width:300px; aspect-ratio: 340/600; background:#111; border-radius:10px; overflow:hidden;">
                <video id="editor-video-preview" style="width:100%; height:100%; object-fit:contain;" playsinline muted></video>
                <div id="processing-overlay" style="position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:none; flex-direction:column; align-items:center; justify-content:center; z-index:10;">
                    <div class="loading" style="position:relative; margin-bottom:10px;">‚è≥</div>
                    <div style="color:white;">Compression... <span id="progress-percent">0%</span></div>
                </div>
            </div>
            
            <!-- Trimming Controls -->
            <div style="width:100%; max-width:340px; margin-top:20px; background:#1a1a1a; padding:15px; border-radius:15px;">
                <div style="display:flex; justify-content:space-between; color:#aaa; font-size:0.8rem; margin-bottom:10px;">
                    <span>D√©but: <b id="lbl-start" style="color:white;">0s</b></span>
                    <span>Dur√©e: <b id="lbl-duration" style="color:#4dabf7;">0s</b></span>
                    <span>Fin: <b id="lbl-end" style="color:white;">0s</b></span>
                </div>
                
                <div style="text-align:center; margin-bottom:10px; font-size:0.9rem; color:#aaa;">
                    Estimation: <b id="lbl-size">0 KB</b>
                </div>
                
                <div style="position:relative; height:30px; margin-bottom:10px;">
                    <!-- Dual Slider Simulation -->
                    <input type="range" id="trim-start" min="0" max="100" value="0" step="0.1" style="position:absolute; width:100%; pointer-events:none; opacity:0.5; z-index:2;">
                    <input type="range" id="trim-end" min="0" max="100" value="100" step="0.1" style="position:absolute; width:100%; pointer-events:none; opacity:0.5; z-index:2;">
                    <div style="position:absolute; top:12px; left:0; width:100%; height:4px; background:#333; border-radius:2px;"></div>
                </div>
                
                <!-- New Controls -->
                <div style="margin-top:15px; border-top:1px solid #333; padding-top:10px;">
                    <button id="btn-define-crop" class="admin-btn" style="width:100%; background:#333; margin-bottom:10px; font-size:0.8rem;">‚úÇÔ∏è D√©finir le recadrage</button>
                    
                    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
                        <label style="color:white; font-size:0.9rem; display:flex; align-items:center; gap:5px;">
                            <input type="checkbox" id="chk-compress" checked> Compresser
                        </label>
                        <select id="sel-quality" style="background:#333; color:white; border:none; padding:5px; border-radius:5px; font-size:0.8rem;">
                            <option value="250000">Faible (250kbps)</option>
                            <option value="564000" selected>Moyenne (500kbps)</option>
                            <option value="1000000">Haute (1Mbps)</option>
                            <option value="2500000">Max (2.5Mbps)</option>
                        </select>
                    </div>
                </div>

                <div style="text-align:center; font-size:0.75rem; color:#666; margin-top:5px;">
                    ‚ö†Ô∏è La vid√©o sera compress√©e (qualit√© r√©duite) pour tenir dans la base de donn√©es.
                </div>
            </div>

            <div class="cropper-controls" style="width:100%; max-width:340px; margin-top:10px;">
                <button id="btn-video-cancel" class="admin-btn btn-crop-cancel">Annuler</button>
                <button id="btn-video-save" class="admin-btn btn-crop-confirm">Compresser & Sauvegarder</button>
            </div>
        </div>
    </div>

    <!-- Sidebar Toggle -->
    <button id="sidebar-toggle" class="sidebar-toggle" style="display:none;">
        <i class="fas fa-list"></i>
    </button>

    <!-- Sidebar -->
    <div class="sidebar-overlay" id="sidebar-overlay"></div>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h3>Mes Souvenirs</h3>
            <button class="close-sidebar" id="close-sidebar"><i class="fas fa-times"></i></button>
        </div>
        <div id="cards-list" class="cards-list"></div>
    </div>

    <div class="admin-wrapper">
        <div class="admin-card">
            <h2 class="admin-title">Connexion Admin</h2>
            
            <div id="login-form" style="display: flex; flex-direction: column; gap: 10px;">
                <input type="email" id="admin-email" class="admin-input" placeholder="Email">
                <input type="password" id="admin-pass" class="admin-input" placeholder="Mot de passe">
                <button id="btn-login" class="admin-btn">Se connecter</button>
            </div>
            
            <div id="admin-form" style="display:none; flex-direction: column; gap: 15px;">
                <!-- Title converted to contenteditable for Memojis -->
                <div id="card-title" class="admin-input" contenteditable="true" placeholder="Titre (ex: Notre voyage üòΩ)"></div>
                
                <!-- Rich Text Div for Stickers/Emojis -->
                <div id="card-text" class="admin-input" contenteditable="true" placeholder="Description..."></div>
                
                <!-- Special Card Options -->
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                    <input type="checkbox" id="is-special" style="width: 20px; height: 20px;">
                    <label for="is-special" style="color: white;">Carte Sp√©ciale (Explosion)</label>
                </div>
                <!-- Explosion input converted to contenteditable -->
                <div id="explosion-emojis" class="admin-input" contenteditable="true" placeholder="Colle tes Memojis/Emojis ici..." style="display: none;"></div>

                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                    <input type="checkbox" id="is-scratch" style="width: 20px; height: 20px;">
                    <label for="is-scratch" style="color: white;">Carte √† Gratter (Surprise)</label>
                </div>

                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                    <input type="checkbox" id="is-flip" style="width: 20px; height: 20px;">
                    <label for="is-flip" style="color: white;">Double Tap (Retourner)</label>
                </div>
                <input type="text" id="flip-text" class="admin-input" placeholder="Texte au dos de la carte..." style="display: none;">

                <!-- Video Input -->
                <div style="border: 1px dashed rgba(255,255,255,0.2); padding: 10px; border-radius: 10px; margin-bottom: 10px;">
                    <label style="color: #aaa; font-size: 0.9rem; display: block; margin-bottom: 5px;">Image ou Vid√©o (Max 800ko pour vid√©o)</label>
                    <input type="file" id="card-image" class="admin-input" accept="image/*,video/mp4,image/gif">
                </div>

                <div style="position: relative;">
                    <img id="preview" class="preview-img">
                    <video id="preview-video" class="preview-img" style="display:none;" loop muted playsinline></video>
                    
                    <button id="btn-recrop" class="admin-btn" style="display:none; margin-top: 5px; background: #333; color: white; font-size: 0.9rem; padding: 10px;">
                        <i class="fas fa-crop-alt"></i> Recadrer l'image actuelle
                    </button>
                </div>
                
                <div style="display:flex; gap:10px;">
                    <button id="btn-add" class="admin-btn" style="flex:1;">Publier</button>
                    <button id="cancel-edit" class="admin-btn" style="flex:1; background:#333; color:white; display:none;">Annuler</button>
                </div>
                <div id="status" style="text-align: center; opacity: 0.7; color: white; margin-top: 10px;"></div>
            </div>
        </div>
    </div>

    <!-- Delete Modal -->
    <div id="delete-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-icon">üóëÔ∏è</div>
            <div class="modal-title">Supprimer ?</div>
            <div class="modal-text">Ce souvenir sera effac√© d√©finitivement. Tu es s√ªr ?</div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" onclick="closeModal()">Annuler</button>
                <button class="modal-btn modal-btn-confirm" id="confirm-delete-btn">Supprimer</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <!-- Storage removed -->

    <script src="firebase-config.js"></script>
    <script>
        // Init Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.firestore();
        const auth = firebase.auth();

        // DOM Elements
        const emailInput = document.getElementById('admin-email');
        const passInput = document.getElementById('admin-pass');
        const loginForm = document.getElementById('login-form');
        const adminForm = document.getElementById('admin-form');
        const title = document.querySelector('.admin-title');

        const btnLogin = document.getElementById('btn-login');
        
        // Sidebar Elements
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const closeSidebarBtn = document.getElementById('close-sidebar');

        // Sidebar Logic
        function openSidebar() {
            sidebar.classList.add('active');
            sidebarOverlay.classList.add('active');
        }

        function closeSidebar() {
            sidebar.classList.remove('active');
            sidebarOverlay.classList.remove('active');
        }

        sidebarToggle.addEventListener('click', openSidebar);
        closeSidebarBtn.addEventListener('click', closeSidebar);
        sidebarOverlay.addEventListener('click', closeSidebar);

        // Auth Logic
        const cancelEditBtn = document.getElementById('cancel-edit');
        const btnAdd = document.getElementById('btn-add');
        let currentEditId = null;
        
        // Check if already logged in
        auth.onAuthStateChanged(user => {
            if (user) {
                showAdminInterface();
            }
        });

        btnLogin.addEventListener('click', login);
        passInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') login(); });

        function login() {
            const email = emailInput.value;
            const password = passInput.value;
            
            auth.signInWithEmailAndPassword(email, password)
                .then(() => {
                    showAdminInterface();
                })
                .catch((error) => {
                    console.error(error);
                    alert("Erreur de connexion : " + error.message);
                });
        }

        function showAdminInterface() {
            adminForm.style.display = 'flex';
            loginForm.style.display = 'none';
            title.innerText = 'Ajouter un souvenir';
            sidebarToggle.style.display = 'flex'; // Show toggle button
            loadAdminCards();
        }

        // Load Cards List
        let sortableInstance = null;

        async function loadAdminCards() {
            const listContainer = document.getElementById('cards-list');
            listContainer.innerHTML = '<div style="text-align:center; color:#888;">Chargement...</div>';
            
            try {
                const snapshot = await db.collection('cards').orderBy('id', 'asc').get();
                listContainer.innerHTML = '';
                
                if (snapshot.empty) {
                    listContainer.innerHTML = '<div style="text-align:center; color:#888;">Aucun souvenir.</div>';
                    return;
                }

                const totalCards = snapshot.size;

                snapshot.forEach(doc => {
                    const data = doc.data();
                    const el = document.createElement('div');
                    el.className = 'admin-list-item';
                    el.setAttribute('data-doc-id', doc.id);
                    
                    // Determine if buttons should be disabled
                    const isFirst = data.id === 1;
                    const isLast = data.id === totalCards;
                    
                    // Feature Icons
                    let icons = '';
                    if (data.isSpecial) icons += '<i class="fas fa-bomb" style="color: #ff6b6b; margin-right: 8px;" title="Explosion"></i>';
                    if (data.isScratch) icons += '<i class="fas fa-eraser" style="color: #adb5bd; margin-right: 8px;" title="√Ä Gratter"></i>';
                    if (data.isFlip) icons += '<i class="fas fa-rotate" style="color: #4dabf7; margin-right: 8px;" title="Retourner"></i>';
                    if (data.video) icons += '<i class="fas fa-video" style="color: #b197fc; margin-right: 8px;" title="Vid√©o"></i>';

                    el.innerHTML = `
                        <div class="drag-handle" style="padding: 10px; cursor: grab; color: #666; display: flex; align-items: center;">
                            <i class="fas fa-grip-vertical"></i>
                        </div>
                        <img src="${data.image}" class="list-thumb" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%23333%22 width=%22100%22 height=%22100%22/%3E%3Ctext fill=%22%23666%22 x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 font-size=%2214%22%3E‚ùå%3C/text%3E%3C/svg%3E'; this.onerror=null;" loading="lazy">
                        <div class="list-info">
                            <div class="list-title">${data.title}</div>
                            <div style="margin-bottom: 4px; font-size: 0.85rem;">${icons}</div>
                            <div class="list-id">#${data.id || '?'}</div>
                        </div>
                        <div class="list-actions">
                            <button class="btn-icon btn-edit" onclick="startEdit('${doc.id}')"><i class="fas fa-pen"></i></button>
                            <button class="btn-icon btn-delete" onclick="deleteCard('${doc.id}')"><i class="fas fa-trash"></i></button>
                        </div>
                    `;
                    listContainer.appendChild(el);
                });

                // Initialize Sortable
                if (sortableInstance) sortableInstance.destroy();
                
                sortableInstance = new Sortable(listContainer, {
                    handle: '.drag-handle',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    onEnd: async function (evt) {
                        const itemEl = evt.item;
                        const newIndex = evt.newIndex; // 0-based
                        const oldIndex = evt.oldIndex; // 0-based
                        
                        if (newIndex === oldIndex) return;

                        // Disable interaction during update
                        listContainer.style.opacity = '0.5';
                        listContainer.style.pointerEvents = 'none';

                        try {
                            // Get all items in new order
                            const items = Array.from(listContainer.children);
                            const batch = db.batch();
                            
                            items.forEach((item, index) => {
                                const docId = item.getAttribute('data-doc-id');
                                const newId = index + 1; // 1-based ID
                                const ref = db.collection('cards').doc(docId);
                                batch.update(ref, { id: newId });
                            });
                            
                            await batch.commit();
                            // Reload to refresh UI and IDs
                            loadAdminCards();
                        } catch (e) {
                            console.error("Error reordering:", e);
                            alert("Erreur lors du r√©arrangement");
                            loadAdminCards(); // Revert
                        } finally {
                            listContainer.style.opacity = '1';
                            listContainer.style.pointerEvents = 'auto';
                        }
                    }
                });

            } catch (e) {
                console.error(e);
                listContainer.innerHTML = '<div style="text-align:center; color:#ff4b4b;">Erreur de chargement.</div>';
            }
        }

        // Move Card Logic
        window.moveCard = async (docId, direction) => {
            // 1. Animation visuelle imm√©diate
            const currentEl = document.querySelector(`.admin-list-item[data-doc-id="${docId}"]`);
            if (!currentEl) return;

            const targetEl = direction === -1 ? currentEl.previousElementSibling : currentEl.nextElementSibling;
            if (!targetEl) return; // Pas de cible visuelle

            // Calculer la distance de d√©placement
            const currentRect = currentEl.getBoundingClientRect();
            const targetRect = targetEl.getBoundingClientRect();
            const distance = targetRect.top - currentRect.top;

            // Appliquer l'animation
            currentEl.style.transition = 'transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)';
            targetEl.style.transition = 'transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)';
            
            currentEl.style.transform = `translateY(${distance}px)`;
            targetEl.style.transform = `translateY(${-distance}px)`;
            
            // Mettre en avant l'√©l√©ment qu'on d√©place
            currentEl.style.zIndex = '10';
            currentEl.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';

            // D√©sactiver les boutons pendant l'animation
            const buttons = document.querySelectorAll('.btn-move');
            buttons.forEach(b => b.disabled = true);

            try {
                const currentDoc = await db.collection('cards').doc(docId).get();
                if (!currentDoc.exists) return;
                
                const currentData = currentDoc.data();
                const currentId = currentData.id;
                const targetId = currentId + direction;
                
                // Find the other card
                const snapshot = await db.collection('cards').where('id', '==', targetId).get();
                
                if (snapshot.empty) {
                    // Reset si erreur
                    currentEl.style.transform = 'none';
                    targetEl.style.transform = 'none';
                    buttons.forEach(b => b.disabled = false);
                    return; 
                }
                
                const targetDoc = snapshot.docs[0];
                
                // Attendre la fin de l'animation (300ms)
                await new Promise(resolve => setTimeout(resolve, 300));

                // Swap IDs
                const batch = db.batch();
                batch.update(db.collection('cards').doc(docId), { id: targetId });
                batch.update(db.collection('cards').doc(targetDoc.id), { id: currentId });
                
                await batch.commit();
                loadAdminCards();
                
            } catch (e) {
                console.error("Error moving card:", e);
                alert("Erreur lors du d√©placement");
                currentEl.style.transform = 'none';
                targetEl.style.transform = 'none';
                buttons.forEach(b => b.disabled = false);
            }
        };

        // Delete Card Logic
        let cardToDeleteId = null;
        const modal = document.getElementById('delete-modal');
        const confirmBtn = document.getElementById('confirm-delete-btn');

        window.deleteCard = (docId) => {
            cardToDeleteId = docId;
            modal.classList.add('active');
        };

        window.closeModal = () => {
            modal.classList.remove('active');
            cardToDeleteId = null;
        };

        confirmBtn.addEventListener('click', async () => {
            if (!cardToDeleteId) return;
            
            const originalText = confirmBtn.innerText;
            confirmBtn.innerText = '...';
            
            try {
                // 1. Delete the card
                await db.collection('cards').doc(cardToDeleteId).delete();
                
                // 2. Re-index remaining cards to ensure sequential IDs (1, 2, 3...)
                const snapshot = await db.collection('cards').orderBy('createdAt', 'asc').get();
                
                if (!snapshot.empty) {
                    const batch = db.batch();
                    let index = 1;
                    
                    snapshot.forEach(doc => {
                        const ref = db.collection('cards').doc(doc.id);
                        batch.update(ref, { id: index });
                        index++;
                    });
                    
                    await batch.commit();
                }

                closeModal();
                loadAdminCards();
            } catch(e) {
                console.error(e);
                alert("Erreur: " + e.message);
            } finally {
                confirmBtn.innerText = originalText;
            }
        });

        // Start Edit
        window.startEdit = async (docId) => {
            const doc = await db.collection('cards').doc(docId).get();
            if(!doc.exists) return;
            
            const data = doc.data();
            document.getElementById('card-title').innerHTML = data.title; // Use innerHTML
            document.getElementById('card-text').innerHTML = data.text; // Use innerHTML for rich text
            
            // Load Special Card Data
            if (data.isSpecial) {
                document.getElementById('is-special').checked = true;
                document.getElementById('explosion-emojis').style.display = 'block';
                document.getElementById('explosion-emojis').innerHTML = data.explosionEmojis || ''; // Use innerHTML
            } else {
                document.getElementById('is-special').checked = false;
                document.getElementById('explosion-emojis').style.display = 'none';
                document.getElementById('explosion-emojis').innerHTML = '';
            }

            if (data.isScratch) {
                document.getElementById('is-scratch').checked = true;
            } else {
                document.getElementById('is-scratch').checked = false;
            }

            if (data.isFlip) {
                document.getElementById('is-flip').checked = true;
                document.getElementById('flip-text').style.display = 'block';
                document.getElementById('flip-text').value = data.flipText || '';
            } else {
                document.getElementById('is-flip').checked = false;
                document.getElementById('flip-text').style.display = 'none';
                document.getElementById('flip-text').value = '';
            }

            preview.src = data.image;
            preview.style.display = 'block';
            preview.onerror = function() {
                this.style.display = 'none';
                status.innerText = '‚ö†Ô∏è Image introuvable';
                setTimeout(() => status.innerText = '', 3000);
            };
            
            // Show recrop button
            document.getElementById('btn-recrop').style.display = 'block';
            
            // Keep existing image
            compressedImageBase64 = data.image;
            
            currentEditId = docId;
            btnAdd.innerText = 'Mettre √† jour';
            cancelEditBtn.style.display = 'block';
            title.innerText = 'Modifier le souvenir';
            
            closeSidebar(); // Close sidebar to show form
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        // Cancel Edit
        cancelEditBtn.addEventListener('click', resetForm);

        // Toggle Special Card Input
        const isSpecialCheckbox = document.getElementById('is-special');
        const explosionEmojisInput = document.getElementById('explosion-emojis');
        const isScratchCheckbox = document.getElementById('is-scratch');
        const isFlipCheckbox = document.getElementById('is-flip');
        const flipTextInput = document.getElementById('flip-text');

        isSpecialCheckbox.addEventListener('change', function() {
            explosionEmojisInput.style.display = this.checked ? 'block' : 'none';
        });

        isFlipCheckbox.addEventListener('change', function() {
            flipTextInput.style.display = this.checked ? 'block' : 'none';
        });

        function resetForm() {
            document.getElementById('card-title').innerHTML = ''; // Reset innerHTML
            document.getElementById('card-text').innerHTML = ''; // Reset innerHTML
            isSpecialCheckbox.checked = false;
            isScratchCheckbox.checked = false;
            isFlipCheckbox.checked = false;
            explosionEmojisInput.innerHTML = ''; // Reset innerHTML
            explosionEmojisInput.style.display = 'none';
            flipTextInput.value = '';
            flipTextInput.style.display = 'none';
            
            fileInput.value = '';
            preview.style.display = 'none';
            previewVideo.style.display = 'none';
            previewVideo.src = '';
            document.getElementById('btn-recrop').style.display = 'none';
            btnAdd.innerText = 'Publier';
            cancelEditBtn.style.display = 'none';
            title.innerText = 'G√©rer les souvenirs';
            currentEditId = null;
            compressedImageBase64 = null;
            videoBase64 = null;
        }

        // Handle paste for images (Memojis/Stickers) in description, title, and explosion
        const richInputs = [
            document.getElementById('card-text'),
            document.getElementById('card-title'),
            document.getElementById('explosion-emojis')
        ];
        
        richInputs.forEach(input => {
            input.addEventListener('paste', function(e) {
                const items = (e.clipboardData || e.originalEvent.clipboardData).items;
                let blob = null;
                
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf("image") === 0) {
                        blob = items[i].getAsFile();
                        break;
                    }
                }
                
                if (blob) {
                    e.preventDefault();
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = `<img src="${event.target.result}">`;
                        document.execCommand('insertHTML', false, img);
                    };
                    reader.readAsDataURL(blob);
                }
            });
        });

        // Image Preview & Compression Logic
        const fileInput = document.getElementById('card-image');
        const preview = document.getElementById('preview');
        const previewVideo = document.getElementById('preview-video');
        let compressedImageBase64 = null;
        let videoBase64 = null; // Store video data
        
        // Cropper Variables
        let cropper = null;
        const cropperModal = document.getElementById('cropper-modal');
        const cropperImage = document.getElementById('cropper-image');
        const btnCropConfirm = document.getElementById('btn-crop-confirm');
        const btnCropCancel = document.getElementById('btn-crop-cancel');
        const btnRecrop = document.getElementById('btn-recrop');

        // Video Editor Variables
        const videoModal = document.getElementById('video-editor-modal');
        const editorVideo = document.getElementById('editor-video-preview');
        const trimStart = document.getElementById('trim-start');
        const trimEnd = document.getElementById('trim-end');
        const lblStart = document.getElementById('lbl-start');
        const lblEnd = document.getElementById('lbl-end');
        const lblDuration = document.getElementById('lbl-duration');
        const btnVideoSave = document.getElementById('btn-video-save');
        const btnVideoCancel = document.getElementById('btn-video-cancel');
        const processingOverlay = document.getElementById('processing-overlay');
        const progressPercent = document.getElementById('progress-percent');
        
        let originalVideoFile = null;

        // New Video Controls
        const btnDefineCrop = document.getElementById('btn-define-crop');
        const chkCompress = document.getElementById('chk-compress');
        const selQuality = document.getElementById('sel-quality');
        let videoCropData = null;
        let isCroppingVideo = false;

        btnDefineCrop.addEventListener('click', () => {
            editorVideo.pause();
            // Capture current frame
            const canvas = document.createElement('canvas');
            canvas.width = editorVideo.videoWidth;
            canvas.height = editorVideo.videoHeight;
            canvas.getContext('2d').drawImage(editorVideo, 0, 0);
            
            isCroppingVideo = true;
            videoModal.style.display = 'none'; // Hide video modal temporarily
            openCropper(canvas.toDataURL());
        });
        
        chkCompress.addEventListener('change', updateVideoLabels);
        selQuality.addEventListener('change', updateVideoLabels);

        // Function to open cropper with an image source
        function openCropper(imageSrc) {
            cropperImage.src = imageSrc;
            cropperModal.style.display = 'flex';
            
            if (cropper) {
                cropper.destroy();
            }
            
            cropper = new Cropper(cropperImage, {
                aspectRatio: 340 / 600,
                viewMode: 1,
                dragMode: 'move',
                autoCropArea: 1,
                restore: false,
                guides: true,
                center: true,
                highlight: false,
                cropBoxMovable: true,
                cropBoxResizable: true,
                toggleDragModeOnDblclick: false,
            });
        }

        // Recrop button handler
        btnRecrop.addEventListener('click', () => {
            if (preview.src && !videoBase64) { // Only recrop if it's an image
                openCropper(preview.src);
            }
        });

        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (file.type.startsWith('video/')) {
                // Open Video Editor
                originalVideoFile = file;
                const url = URL.createObjectURL(file);
                editorVideo.src = url;
                
                // Reset Crop Data
                videoCropData = null;
                btnDefineCrop.innerText = "‚úÇÔ∏è D√©finir le recadrage";
                btnDefineCrop.style.background = "#333";
                
                editorVideo.onloadedmetadata = () => {
                    videoModal.style.display = 'flex';
                    
                    // Force play to ensure preview is visible on iOS
                    editorVideo.play().then(() => {
                        editorVideo.pause();
                        editorVideo.currentTime = 0;
                    }).catch(e => console.log("Auto-play for preview prevented", e));
                    
                    // Reset sliders
                    trimStart.min = 0;
                    trimStart.max = editorVideo.duration;
                    trimStart.value = 0;
                    
                    trimEnd.min = 0;
                    trimEnd.max = editorVideo.duration;
                    trimEnd.value = editorVideo.duration;
                    
                    updateVideoLabels();
                };

            } else {
                // Handle Image
                videoBase64 = null; // Reset video
                previewVideo.style.display = 'none';
                previewVideo.src = '';
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    openCropper(event.target.result);
                }
                reader.readAsDataURL(file);
            }
            fileInput.value = '';
        });

        // Video Editor Logic
        function updateVideoLabels() {
            const start = parseFloat(trimStart.value);
            const end = parseFloat(trimEnd.value);
            
            // Ensure start < end
            if (start >= end) {
                trimStart.value = end - 0.5;
            }
            
            const duration = parseFloat(trimEnd.value) - parseFloat(trimStart.value);
            
            lblStart.innerText = parseFloat(trimStart.value).toFixed(1) + 's';
            lblEnd.innerText = parseFloat(trimEnd.value).toFixed(1) + 's';
            lblDuration.innerText = duration.toFixed(1) + 's';
            
            // Estimate Size
            let bitrate = 500000; // Default
            if (chkCompress.checked) {
                bitrate = parseInt(selQuality.value);
            } else {
                // If not compressing, assume High Quality ~2.5Mbps
                bitrate = 2500000; 
            }
            
            // Audio overhead ~64kbps -> 64000
            const totalBitrate = bitrate + 64000;
            
            // Size in KB = (Duration * totalBitrate) / 8 / 1024
            const estimatedSizeKB = (duration * totalBitrate) / 8192;
            
            const lblSize = document.getElementById('lbl-size');
            if (lblSize) {
                lblSize.innerText = Math.round(estimatedSizeKB) + ' KB';
                if (estimatedSizeKB > 950) {
                    lblSize.style.color = '#ff6b6b'; // Red warning
                } else {
                    lblSize.style.color = '#51cf66'; // Green ok
                }
            }
            
            editorVideo.currentTime = parseFloat(trimStart.value);
        }

        trimStart.addEventListener('input', () => {
            updateVideoLabels();
            editorVideo.currentTime = parseFloat(trimStart.value);
        });
        
        trimEnd.addEventListener('input', () => {
            updateVideoLabels();
            editorVideo.currentTime = parseFloat(trimEnd.value);
        });
        
        // Enable pointer events for sliders
        trimStart.style.pointerEvents = 'auto';
        trimEnd.style.pointerEvents = 'auto';

        btnVideoCancel.addEventListener('click', () => {
            videoModal.style.display = 'none';
            editorVideo.pause();
            editorVideo.src = '';
            originalVideoFile = null;
        });

        btnVideoSave.addEventListener('click', async () => {
            const start = parseFloat(trimStart.value);
            const end = parseFloat(trimEnd.value);
            const duration = end - start;
            
            if (duration > 15) {
                alert("La vid√©o est trop longue ! Essaye de garder moins de 10-15 secondes.");
                return;
            }

            processingOverlay.style.display = 'flex';
            editorVideo.pause();
            
            // Compression Logic using Canvas Recording
            const canvas = document.createElement('canvas');
            
            // Determine Resolution and Bitrate
            let targetBitrate = 500000;
            
            if (chkCompress.checked) {
                // Low resolution for size
                canvas.width = 320; 
                canvas.height = 568;
                targetBitrate = parseInt(selQuality.value);
            } else {
                // High resolution (capped at 720p width to avoid crashes)
                const aspectRatio = 340/600;
                canvas.width = Math.min(editorVideo.videoWidth, 720);
                canvas.height = canvas.width / aspectRatio;
                targetBitrate = 2500000; // 2.5 Mbps
            }
             
            const ctx = canvas.getContext('2d');
            
            // Setup MediaRecorder
            const stream = canvas.captureStream(30); // 30 FPS
            const chunks = [];
            
            // Try to use efficient codecs
            let mimeType = 'video/webm;codecs=vp8';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'video/mp4'; // Safari fallback
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = ''; // Default
                }
            }
            
            const options = mimeType ? { mimeType, videoBitsPerSecond: targetBitrate } : { videoBitsPerSecond: targetBitrate };
            
            let recorder;
            try {
                recorder = new MediaRecorder(stream, options);
            } catch (e) {
                console.warn("Recorder error, trying default", e);
                recorder = new MediaRecorder(stream);
            }

            recorder.ondataavailable = e => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            recorder.onstop = async () => {
                const blob = new Blob(chunks, { type: mimeType || 'video/webm' });
                console.log("Compressed size:", (blob.size / 1024).toFixed(2) + "KB");
                
                if (blob.size > 950 * 1024) {
                    alert("La vid√©o est encore trop lourde (" + (blob.size/1024).toFixed(0) + "KB). R√©duis la dur√©e !");
                    processingOverlay.style.display = 'none';
                    return;
                }

                // Convert to Base64
                const reader = new FileReader();
                reader.onloadend = () => {
                    videoBase64 = reader.result;
                    
                    // Generate Thumbnail
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = canvas.width;
                    thumbCanvas.height = canvas.height;
                    thumbCanvas.getContext('2d').drawImage(editorVideo, 0, 0, thumbCanvas.width, thumbCanvas.height);
                    compressedImageBase64 = thumbCanvas.toDataURL('image/jpeg', 0.7);
                    
                    // Update UI
                    previewVideo.src = videoBase64;
                    previewVideo.style.display = 'block';
                    preview.style.display = 'none';
                    btnRecrop.style.display = 'none';
                    
                    // Force play for preview visibility
                    previewVideo.play().catch(e => console.log("Preview play failed", e));
                    
                    videoModal.style.display = 'none';
                    processingOverlay.style.display = 'none';
                    editorVideo.src = ''; // Cleanup
                };
                reader.readAsDataURL(blob);
            };

            // Start Recording Process
            recorder.start();
            editorVideo.currentTime = start;
            
            // Play and Draw Loop
            await editorVideo.play();
            
            const drawFrame = () => {
                if (editorVideo.currentTime >= end || editorVideo.paused) {
                    recorder.stop();
                    editorVideo.pause();
                    return;
                }
                
                if (videoCropData) {
                    // Use custom crop
                    ctx.drawImage(editorVideo, 
                        videoCropData.x, videoCropData.y, videoCropData.width, videoCropData.height, 
                        0, 0, canvas.width, canvas.height
                    );
                } else {
                    // Draw center crop to fit aspect ratio (Default)
                    const vidRatio = editorVideo.videoWidth / editorVideo.videoHeight;
                    const canvasRatio = canvas.width / canvas.height;
                    
                    let sx, sy, sWidth, sHeight;
                    
                    if (vidRatio > canvasRatio) {
                        // Video is wider
                        sHeight = editorVideo.videoHeight;
                        sWidth = sHeight * canvasRatio;
                        sx = (editorVideo.videoWidth - sWidth) / 2;
                        sy = 0;
                    } else {
                        // Video is taller
                        sWidth = editorVideo.videoWidth;
                        sHeight = sWidth / canvasRatio;
                        sx = 0;
                        sy = (editorVideo.videoHeight - sHeight) / 2;
                    }
                    
                    ctx.drawImage(editorVideo, sx, sy, sWidth, sHeight, 0, 0, canvas.width, canvas.height);
                }
                
                // Update progress
                const progress = ((editorVideo.currentTime - start) / duration) * 100;
                progressPercent.innerText = Math.min(100, Math.round(progress)) + '%';
                
                requestAnimationFrame(drawFrame);
            };
            
            drawFrame();
        });

        btnCropCancel.addEventListener('click', () => {
            cropperModal.style.display = 'none';
            if (cropper) {
                cropper.destroy();
                cropper = null;
            }
        });

        btnCropConfirm.addEventListener('click', () => {
            if (!cropper) return;
            
            if (isCroppingVideo) {
                // Save crop data for video
                videoCropData = cropper.getData();
                
                // Close cropper and return to video editor
                cropperModal.style.display = 'none';
                cropper.destroy();
                cropper = null;
                
                videoModal.style.display = 'flex';
                isCroppingVideo = false;
                
                // Update button text to show crop is set
                btnDefineCrop.innerText = "‚úÖ Recadrage d√©fini";
                btnDefineCrop.style.background = "#51cf66";
                
            } else {
                // Get cropped canvas
                const canvas = cropper.getCroppedCanvas({
                    width: 680, // 2x for retina
                    height: 1200,
                    imageSmoothingEnabled: true,
                    imageSmoothingQuality: 'high',
                });
                
                // Compress to JPEG
                compressedImageBase64 = canvas.toDataURL('image/jpeg', 0.8);
                
                // Show preview
                preview.src = compressedImageBase64;
                preview.style.display = 'block';
                preview.onerror = function() {
                    this.style.display = 'none';
                    status.innerText = '‚ö†Ô∏è Erreur lors du chargement de l\'image';
                    setTimeout(() => status.innerText = '', 3000);
                };
                btnRecrop.style.display = 'block'; // Show recrop button for the new image
                
                // Close modal
                cropperModal.style.display = 'none';
                cropper.destroy();
                cropper = null;
            }
        });

        // Upload / Update Logic
        btnAdd.addEventListener('click', async () => {
            const titleVal = document.getElementById('card-title').innerHTML; // Get innerHTML
            const textVal = document.getElementById('card-text').innerHTML; // Get innerHTML
            const isSpecial = document.getElementById('is-special').checked;
            const isScratch = document.getElementById('is-scratch').checked;
            const isFlip = document.getElementById('is-flip').checked;
            const explosionEmojis = document.getElementById('explosion-emojis').innerHTML; // Get innerHTML
            const flipText = document.getElementById('flip-text').value;
            const status = document.getElementById('status');

            if (!titleVal || !compressedImageBase64) {
                alert('Il faut au moins un titre et une image (ou vid√©o) !');
                return;
            }

            status.innerText = currentEditId ? 'Mise √† jour...' : 'Envoi en cours...';
            
            try {
                const cardData = {
                    title: titleVal,
                    text: textVal,
                    image: compressedImageBase64,
                    video: videoBase64 || null, // Save video if exists
                    isSpecial: isSpecial,
                    isScratch: isScratch,
                    isFlip: isFlip,
                    explosionEmojis: isSpecial ? explosionEmojis : null,
                    flipText: isFlip ? flipText : null,
                };

                if (currentEditId) {
                    // Update existing
                    cardData.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                    await db.collection('cards').doc(currentEditId).update(cardData);
                    status.innerText = 'Modifi√© avec succ√®s !';
                } else {
                    // Create new
                    const snapshot = await db.collection('cards').get();
                    const count = snapshot.size;
                    
                    cardData.id = count + 1;
                    cardData.createdAt = firebase.firestore.FieldValue.serverTimestamp();

                    await db.collection('cards').add(cardData);
                    status.innerText = 'Ajout√© avec succ√®s !';
                }
                
                resetForm();
                loadAdminCards();
                
            } catch (error) {
                console.error(error);
                status.innerText = 'Erreur: ' + error.message;
            }
        });
    </script>
</body>
</html>
